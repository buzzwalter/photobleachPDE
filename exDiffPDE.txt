#Crank Nicholson PDE Solver for parabolic PDE
#Description: We start with a gaussian curve representing the intitial condition and solve the diffusion eq.
#            using the Crank Nicholson method.

import numpy as np
import scipy as sp
from scipy.linalg import solve_banded
import math
import matplotlib.pyplot as plt
dx = 0.5 
dt = 0.05
a = 249.
r = dt/(2*dx**2)
bL = 1
bR = 1
x1 = -r*np.ones(1000)
x1[0] = 0
x1[-1] = 0
x2 = (1+2*r)*np.ones(1000) 
x3 = x1
A = np.array([x1,x2,x3])

# thms(b)
#Description: Takes in the discritized explicit formula of the PDE and solves Ax=b where 
#            A is a constant tridiagonal matrix.
#Parameters:  b - An array representing the right hand side of explicit formula
#             x1 - An array representing the first diagonal in the matrix located above the middle row
#             x2 - An array representing the middle diagonal in the matrix
#             x3 - An array representing the lower diagonal in the matrix 
#Returns:  X as a solution representing the next time step solution for the whole spatial domain

def thms(x1,x2,x3,b):
   C = np.zeros(len(x1))
   D = np.zeros(len(b))
   X = np.zeros(len(b))
   for i in range(len(x1))
      if i = 0:
         c[i] = x1[i]/x2[i]
      if i != 0:
         C = x1[i]/(x2[i]-x3[i]*C[i-1])
   for i in range(len(b))
      if i = 0:
         D[i] = b[i]/x2[i]
      if i != 0:
         D = (b[i]-x3[i]*D[i-1])/(x2[i]-x3[i]*C[i-1])
   for i in range(len(b))
      if i = 0:
         X[len(b)-i] = D[len(b)-i]
      if i != 0:
         X[len(b)-i] = D[len(b)-i] - C[len(b)-i]*X[len(b)-i+1]
   return X

# u0(x)
#Description:  Sets up the intial condition for the PDE.
#Parameters:  x - an array representing the domain.
#Returns:  The discrete initial condition.

def u0(x):
   return np.add(np.ones(len(x)), -0.5*np.exp(-(x - a)**2))

F = np.zeros((20,1000), dtype = float)
b = np.arange(1000)
F[0] = u0(b*dx)
for j in range(19): 
   F1j = np.concatenate((F[j][1:], F[j][:1]))
   Fj1 = np.concatenate((F[j][999:],F[j][:999])) 
   b = r*F1j + (1-2*r)*F[j] + r*Fj1
   b[0] = r*F[j][1] + (1-2*r)*F[j][0] + 2*r*bL  
   b[-1] = r*F[j][-2] + (1-2*r)*F[j][-1] + 2*r*bR
   F[j+1] = thms(b)
