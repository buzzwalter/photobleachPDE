#Crank Nicholson PDE Solver for parabolic PDE
#Description: We start with a gaussian curve representing the intitial condition and solve the diffusion eq.
#            using the Crank Nicholson method.

import numpy as np
import scipy as sp
from scipy.linalg import solve_banded
import math
import matplotlib.pyplot as plt
dx = 0.5 
dt = 0.05
n = 6
a = math.floor((n-1)*dx/2)
r = dt/(2*dx**2)
bL = 1
bR = 1
x1 = -r*np.ones(n)
x1[0] = 0
x1[-1] = 0
x2 = (1+2*r)*np.ones(n) 
x3 = x1
A = np.array([x1,x2,x3])

# thms(b)
#Description: Takes in the discritized explicit formula of the PDE and solves Ax=b where 
#            A is a constant tridiagonal matrix.
#Parameters:  b - An array representing the right hand side of explicit formula
#             x1 - An array representing the first diagonal in the matrix located above the middle row
#             x2 - An array representing the middle diagonal in the matrix
#             x3 - An array representing the lower diagonal in the matrix 
#Returns:  X as a solution representing the next time step solution for the whole spatial domain

def thms(x1,x2,x3,b):
   C = np.zeros(len(x1))
   D = np.zeros(len(b))
   X = np.zeros(len(b))
   for i in range(len(b)):
      if i == 0:
         C[i] = x1[i]/x2[i]
         D[i] = b[i]/x2[i]
      elif i < (len(b)-1):
        C[i] = x1[i]/(x2[i]-x3[i]*C[i-1])
        D[i] = (b[i]-x3[i]*D[i-1])/(x2[i]-x3[i]*C[i-1])
      else:
        D[i] = (b[i]-x3[i]*D[i-1])/(x2[i]-x3[i]*C[i-1])
   for i in range(len(b)):
      if i == 0:
         X[len(b)-i-1] = D[len(b)-i-1]
      else: 
         X[len(b)-i-1] = D[len(b)-i-1] - C[len(b)-i-1]*X[len(b)-i]
   return X

# u0(x)
#Description:  Sets up the intial condition for the PDE.
#Parameters:  x - an array representing the domain.
#Returns:  The discrete initial condition.

def u0(x):
   return np.add(np.ones(len(x)), -0.5*np.exp(-(x - a)**2))

F = np.zeros((20,n), dtype = float)
b = np.arange(n)
F[0] = u0(b*dx)
for j in range(19): 
   F1j = np.concatenate((F[j][1:], F[j][:1]))
   Fj1 = np.concatenate((F[j][(n-1):],F[j][:(n-1)])) 
   b = r*F1j + (1-2*r)*F[j] + r*Fj1
   b[0] = r*F[j][1] + (1-2*r)*F[j][0] + 2*r*bL  
   b[-1] = r*F[j][-2] + (1-2*r)*F[j][-1] + 2*r*bR
   F[j+1] = thms(x1,x2,x3,b)
print(F[0])
print(F[5])
print(F[13])
